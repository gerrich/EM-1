Для профилирования использовалась машина с SSD.

условимся об обозначаниях:
B - размер блока
M - размер памяти
N - размер задачи

Я реализовал просетйший вариант алгоритма сортировки слиянием.
1й этап - сортировк кусков размером M.
2й этап - сливание отсортированных куском по 2 за раз.

Вопросы 2,3)

оценим сложность записи блока:
    cost(B) = C_0 + B*C_1,
   
запись отсортированного массива пямяти размером M:
    cost(M) = C_0 + M*C_1,
    !!! cost(M) >> cost(B)
Отмечу, что С_1*B ~ С0, из-за малого времени доступа на SSD

Общая оценка сложности для алгоритма:
    
    cost = N/B*cost(B) + N/M*(cost(M) + C_2 * M*log_2(M)) + N/B*cost(B)*log_2(N/M)
    cost = [копирование] + [сортировка кусков] + [слияние]
    cost = N/B*cost(B)*(log_2(N/M) + 1) + N/M*(cost(M) + C_2 * M*log_2(M))

вотоорое слогаемое не зависит от B, т.е. С_0 << C_1*B
При этом время работы программы не меняется с изменением B [512k->4m]

    упростим:
    cost = N*(С_1*(log_2(N) + 2) + (C_2-C_1)*log_2(M))
    N*(C_2-C_1) * log(256/8)  = T(M=256) - T(M=8) = -56s.
    N*(C_2-C_1) = -11s. 
    N*С_1*(log_2(N) + 2) = T(M=32) - log(32)*11s = 160c

Вопрос 1) Оптимальное сол-ко IO операций не выдерживается, зато выдерживается
приведённая в отчёте оценка. По хорошему надо сливать по несколько блоков ;-)

кол-во операций IO:
    io = N/B + N/M + N/B*log_2(N/M)
    при B << M, io ~ B^-1, что продтверждается экспериментом (io = io(B), N = const, M = const)

